<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonvi omniPD model calculator</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&family=Crimson+Pro:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: linear-gradient(-45deg, #667eea, #764ba2, #f093fb, #4facfe);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes gradientCycle {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            animation: fadeInDown 0.6s ease-out;
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 15px;
            letter-spacing: -0.02em;
        }

        .version {
            font-family: 'Fira Code', monospace;
            font-size: 0.875rem;
            opacity: 0.9;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.95);
            letter-spacing: 0.01em;
        }

        .info-box {
            background: white;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            animation: fadeInUp 0.6s ease-out;
            border-left: 5px solid #667eea;
        }

        .info-box p {
            color: #666;
            margin-bottom: 10px;
            line-height: 1.8;
        }

        .section {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            animation: fadeInUp 0.6s ease-out;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
        }

        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 50px rgba(0,0,0,0.15);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 25px;
            font-size: 2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .input-field {
            display: flex;
            flex-direction: column;
        }

        label {
            font-size: 0.9rem;
            color: #667eea;
            margin-bottom: 8px;
            font-family: 'Fira Code', monospace;
            font-weight: 600;
        }

        input[type="text"],
        input[type="number"],
        input[type="file"],
        select {
            background: #f7f9fc;
            border: 2px solid #e0e7ff;
            color: #333;
            padding: 12px;
            border-radius: 10px;
            font-size: 1rem;
            font-family: 'Fira Code', monospace;
            transition: all 0.3s ease;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        input:hover,
        select:hover {
            border-color: #667eea;
        }

        button {
            background: linear-gradient(-45deg, #667eea, #764ba2, #f093fb, #667eea);
            background-size: 300% 300%;
            animation: gradientCycle 3s ease infinite;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Crimson Pro', serif;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
        }

        button::before, .add-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before, .add-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }
        .add-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(82, 199, 135, 0.5);
        }

        button:active, .add-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f7f9fc 0%, #e0e7ff 100%);
            border: 2px solid #e0e7ff;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }

        .stat-card h3 {
            color: #764ba2;
            font-size: 1rem;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(102, 126, 234, 0.1);
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #666;
        }

        .selected-points-list {
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.85rem;
        }

        .selected-point-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(102, 126, 234, 0.05);
            color: #555;
        }

        .selected-point-item:last-child {
            border-bottom: none;
        }

        .point-time {
            color: #666;
        }

        .point-power {
            font-weight: 600;
            color: #667eea;
        }

        .stat-value {
            color: #667eea;
            font-weight: 600;
        }

        #chartContainer1,
        #chartContainer2,
        #chartContainer3 {
            width: 100%;
            height: 500px;
            margin-top: 30px;
            background: #f7f9fc;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }

        .chart-full-width {
            grid-column: 1 / -1;
            height: 600px;
            min-height: 600px;
        }

        @media (max-width: 1200px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-full-width {
                grid-column: auto;
            }
        }

        .manual-inputs {
            background: #f7f9fc;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid #e0e7ff;
        }

        .input-row-container {
            margin-bottom: 15px;
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 15px;
            align-items: end;
            margin-bottom: 10px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #e0e7ff;
            transition: all 0.3s ease;
        }

        .input-row:hover {
            border-color: #667eea;
            transform: translateX(5px);
        }

        .remove-btn {
            background: #ff6b6b;
            padding: 10px 15px;
            font-size: 0.9rem;
            min-width: auto;
        }

        .add-btn {
            background: linear-gradient(-45deg, #52c787, #4CAF50, #66BB6A, #52c787);
            background-size: 300% 300%;
            animation: gradientCycle 3s ease infinite;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Crimson Pro', serif;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 15px rgba(82, 199, 135, 0.3);
            position: relative;
            overflow: hidden;
            margin-top: 10px;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 10px;
            margin-top: 15px;
            font-family: 'Fira Code', monospace;
            animation: fadeInUp 0.4s ease-out;
        }

        .alert-success {
            background: rgba(82, 199, 135, 0.1);
            border: 2px solid #52c787;
            color: #2d6a4f;
        }

        .alert-warning {
            background: rgba(240, 160, 71, 0.1);
            border: 2px solid #f0a047;
            color: #b87503;
        }

        .quick-calc-result {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            font-size: 1.5rem;
            font-weight: 700;
            text-align: center;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            animation: fadeInUp 0.5s ease-out;
        }

        .csv-controls {
            background: #f7f9fc;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border: 2px solid #e0e7ff;
        }

        .file-upload-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-upload-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }

        .file-upload-label {
            display: block;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .file-upload-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease-out;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: slideUp 0.4s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .modal-content h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }

        .modal-content p {
            color: #666;
            margin-bottom: 25px;
            font-size: 1.1rem;
        }

        .modal-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }

            .input-group {
                grid-template-columns: 1fr;
            }

            .input-row {
                grid-template-columns: 1fr;
            }

            #chartContainer {
                height: 400px;
            }
        }

        footer {
            text-align: center;
            padding: 30px;
            color: white;
            margin-top: 50px;
            animation: fadeInUp 0.8s ease-out;
        }

        footer a {
            color: white;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        footer a:hover {
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>omniPD Model Calculator</h1>
            <div class="version">v0.3.0 - Created by Andrea Bonvicin</div>
        </header>

        <div class="info-box">
                        <p><strong>üìä Modello omniPD</strong> - Calcolo dei parametri di potenza (CP, W', Pmax, A) basato sul modello OmniPD.</p>
                        <p>Importa un file CSV con colonne tempo/potenza oppure inserisci i dati manualmente. Il modello fitter√† la curva secondo la seguente formula a due parti:<br>P(t) = (W'/t) √ó (1 - e^(-t √ó (Pmax - CP) / W')) + CP per t ‚â§ TCPmax;<br>P(t) = (W'/t) √ó (1 - e^(-t √ó (Pmax - CP) / W')) + CP - A √ó ln(t / TCPmax) per t &gt; TCPmax, dove TCPmax = 1800 s (30 minuti).</p></pre>
        </div>

        <!-- Manual Input Section -->
        <div class="section">
            <h2>üìù Inserimento Manuale</h2>
            <div class="manual-inputs" id="manualInputsContainer">
                <!-- Rows will be generated by JavaScript -->
            </div>
            <button onclick="calculateFromManual()" style="margin-top: 15px; width: 300px;">üî¢ Calcola CP</button>
            <button class="add-btn" onclick="addInputRow()" style="margin-top: 15px; width: 300px;">‚ûï Aggiungi Riga</button>
        </div>

        <!-- CSV Import Section -->
        <div class="section">
            <h2>üìÇ Importa da CSV</h2>
            <div class="input-field">
                <label>Seleziona file CSV</label>
                <div class="file-upload-wrapper">
                    <input type="file" id="csvFile" accept=".csv" onchange="handleFileUpload(event)">
                    <label for="csvFile" class="file-upload-label">
                        üìÅ Scegli file CSV...
                    </label>
                </div>
            </div>

            <div id="csvControls" class="csv-controls" style="display: none;">
                <div class="input-group">
                    <div class="input-field">
                        <label>Colonna Tempo (s)</label>
                        <select id="colTime"></select>
                    </div>
                    <div class="input-field">
                        <label>Colonna Potenza (W)</label>
                        <select id="colPower"></select>
                    </div>
                </div>

                <div class="input-group">
                    <div class="input-field">
                        <label>Valori per finestra</label>
                        <input type="number" id="valuesPerWindow" value="1" min="1">
                    </div>
                    <div class="input-field">
                        <label>Percentile minimo</label>
                        <input type="number" id="minPercentile" value="80" min="0" max="100">
                    </div>
                </div>

                <div class="input-group">
                    <div class="input-field">
                        <label>Durata sprint (s)</label>
                        <input type="number" id="sprintSeconds" value="10" min="1">
                    </div>
                </div>

                <button onclick="importCSVData()">üìä Calcola</button>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="section" style="display: none;">
            <h2>üìà Risultati</h2>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>Parametri Modello</h3>
                    <div class="stat-item">
                        <span class="stat-label">CP:</span>
                        <span class="stat-value" id="cpValue">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">W':</span>
                        <span class="stat-value" id="wprimeValue">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">99% W'eff at:</span>
                        <span class="stat-value" id="t99Value">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Pmax:</span>
                        <span class="stat-value" id="pmaxValue">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">A:</span>
                        <span class="stat-value" id="aValue">-</span>
                    </div>
                </div>

                <div class="stat-card">
                    <h3>Statistiche Fit</h3>
                    <div class="stat-item">
                        <span class="stat-label">RMSE:</span>
                        <span class="stat-value" id="rmseValue">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">MAE:</span>
                        <span class="stat-value" id="maeValue">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Punti usati:</span>
                        <span class="stat-value" id="pointsValue">-</span>
                    </div>
                </div>

                <div class="stat-card">
                    <h3>Valori Teorici</h3>
                    <div class="stat-item">
                        <span class="stat-label">P @ 5min:</span>
                        <span class="stat-value" id="p5minValue">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">P @ 20min:</span>
                        <span class="stat-value" id="p20minValue">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">P @ 30min:</span>
                        <span class="stat-value" id="p30minValue">-</span>
                    </div>
                </div>

                <div class="stat-card" id="selectedPointsCard" style="display: none;">
                    <h3>Punti Filtrati</h3>
                    <div id="selectedPointsList" class="selected-points-list">
                        <!-- I punti selezionati verranno popolati qui -->
                    </div>
                </div>
            </div>

            <div class="charts-grid">
                <div id="chartContainer1" class="chart-full-width"></div>
                <div id="chartContainer2"></div>
                <div id="chartContainer3"></div>
            </div>
        </div>

        <!-- Quick Calculator Section -->
        <div class="section">
            <h2>‚ö° Calcolo Rapido</h2>
            <p style="color: #666; margin-bottom: 20px;">Calcola la potenza per un tempo specifico usando i parametri ottenuti.</p>
            <div class="input-group">
                <div class="input-field">
                    <label>Tempo (secondi)</label>
                    <input type="number" id="tCalc" value="1200" min="1" onkeypress="if(event.key==='Enter') quickCalculate()">
                </div>
            </div>
            <div id="quickResult" style="margin-top: 20px;"></div>
        </div>

        <footer>
            <a href="https://linktr.ee/bonvicin.coaching" target="_blank">
                <p>&copy; 2026 Andrea Bonvicin - omniPD Calculator - Licenza MIT</p>
            </a>
        </footer>
    </div>

    <!-- Custom Modal -->
    <div id="customModal" class="modal">
        <div class="modal-content">
            <span class="modal-icon">‚ö†Ô∏è</span>
            <h3 id="modalTitle">Attenzione</h3>
            <p id="modalMessage">Messaggio di avviso</p>
            <button class="modal-btn" onclick="closeModal()">OK</button>
        </div>
    </div>

    <script>
        // Costanti
        const TCPMAX = 1800;
        let calculatedParams = null;
        let csvData = null;
        let chart = null;
        let allTimes = [];      // Tutti i dati grezzi
        let allPowers = [];     // Tutte le potenze grezze
        let allResiduals = [];  // Residui calcolati dal modello su tutti i dati

        // Funzioni matematiche del modello
        function ompd_power(t, CP, W_prime, Pmax, A) {
            const base = (W_prime / t) * (1 - Math.exp(-t * (Pmax - CP) / W_prime)) + CP;
            return t <= TCPMAX ? base : base - A * Math.log(t / TCPMAX);
        }

        function w_eff(t, W_prime, CP, Pmax) {
            return W_prime * (1 - Math.exp(-t * (Pmax - CP) / W_prime));
        }

        function formatTimeLabel(seconds) {
            // Round to nearest integer to remove decimals
            seconds = Math.round(seconds);
            
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const hours = Math.floor(seconds / 3600);
            
            if (hours > 0 && minutes % 60 === 0 && secs === 0) {
                return `${hours}h`;
            } else if (minutes > 0 && secs === 0) {
                return `${minutes}m`;
            } else if (minutes > 0) {
                return `${minutes}m${secs}s`;
            } else {
                return `${seconds}s`;
            }
        }

        // Curve fitting (Nelder-Mead semplificato)
        function curveFit(timeValues, powerValues) {
            // Stima iniziale
            const sortedPower = [...powerValues].sort((a, b) => a - b);
            const CP_init = sortedPower[Math.floor(sortedPower.length * 0.3)];
            const W_prime_init = 20000;
            const Pmax_init = Math.max(...powerValues);
            const A_init = 5;

            let params = [CP_init, W_prime_init, Pmax_init, A_init];
            
            // Ottimizzazione semplificata
            const maxIter = 1000;
            let step = [10, 1000, 10, 0.5];
            
            for (let iter = 0; iter < maxIter; iter++) {
                const currentError = calculateError(params, timeValues, powerValues);
                let improved = false;

                for (let i = 0; i < params.length; i++) {
                    const testParams = [...params];
                    testParams[i] += step[i];
                    const testError = calculateError(testParams, timeValues, powerValues);
                    
                    if (testError < currentError) {
                        params = testParams;
                        improved = true;
                    } else {
                        testParams[i] = params[i] - step[i];
                        const testError2 = calculateError(testParams, timeValues, powerValues);
                        if (testError2 < currentError) {
                            params = testParams;
                            improved = true;
                        }
                    }
                }

                if (!improved) {
                    step = step.map(s => s * 0.9);
                }
                
                if (step.every(s => Math.abs(s) < 0.01)) break;
            }

            return params;
        }

        function calculateError(params, timeValues, powerValues) {
            let sumSquaredError = 0;
            for (let i = 0; i < timeValues.length; i++) {
                const predicted = ompd_power(timeValues[i], ...params);
                const error = powerValues[i] - predicted;
                sumSquaredError += error * error;
            }
            return sumSquaredError;
        }

        // Perform calculation

        // Populate selected points card for CSV data
        function populateSelectedPointsCard(timeValues, powerValues) {
            const card = document.getElementById('selectedPointsCard');
            const list = document.getElementById('selectedPointsList');
            
            // Clear previous content
            list.innerHTML = '';
            
            // Add each selected point
            timeValues.forEach((time, index) => {
                const power = powerValues[index];
                const pointDiv = document.createElement('div');
                pointDiv.className = 'selected-point-item';
                pointDiv.innerHTML = `
                    <span class="point-time">${formatTimeLabel(time)}</span>
                    <span class="point-power">${Math.round(power)} W</span>
                `;
                list.appendChild(pointDiv);
            });
            
            // Show the card
            card.style.display = 'block';
        }

        function performCalculation(timeValues, powerValues) {
            // Fit del modello
            const params = curveFit(timeValues, powerValues);
            
            // Se non ci sono dati oltre TCPMAX30 minuti (1800s), A = 5
            const hasLongData = Math.max(...timeValues) > 1800;
            if (!hasLongData) {
                params[3] = 5;
            }
            
            const [CP, W_prime, Pmax, A] = params;
            
            calculatedParams = { CP, W_prime, Pmax, A };

            // Calcolo predizioni e residui
            const predictions = timeValues.map(t => ompd_power(t, CP, W_prime, Pmax, A));
            const residuals = powerValues.map((p, i) => p - predictions[i]);
            const RMSE = Math.sqrt(residuals.reduce((sum, r) => sum + r * r, 0) / residuals.length);
            const MAE = residuals.reduce((sum, r) => sum + Math.abs(r), 0) / residuals.length;

            // W'eff
            const t_99_range = Array.from({length: 500}, (_, i) => 1 + i * (180 - 1) / 499);
            const weff_vals = t_99_range.map(t => w_eff(t, W_prime, CP, Pmax));
            const W_99 = 0.99 * W_prime;
            const t_99_idx = weff_vals.reduce((minIdx, val, idx, arr) => 
                Math.abs(val - W_99) < Math.abs(arr[minIdx] - W_99) ? idx : minIdx, 0);
            const t_99 = t_99_range[t_99_idx];

            // Valori teorici
            const durations = [300, 600, 900, 1200, 1800];
            const predictedPowers = durations.map(t => Math.round(ompd_power(t, CP, W_prime, Pmax, A)));

            // Update stats display
            document.getElementById('cpValue').textContent = Math.round(CP) + ' W';
            document.getElementById('wprimeValue').textContent = Math.round(W_prime) + ' J';
            document.getElementById('pmaxValue').textContent = Math.round(Pmax) + ' W';
            document.getElementById('aValue').textContent = A.toFixed(2);
            document.getElementById('rmseValue').textContent = RMSE.toFixed(2);
            document.getElementById('maeValue').textContent = MAE.toFixed(2);
            document.getElementById('pointsValue').textContent = timeValues.length;
            document.getElementById('t99Value').textContent = formatTimeLabel(t_99);

            // Calculate benchmark powers
            document.getElementById('p5minValue').textContent = Math.round(ompd_power(300, CP, W_prime, Pmax, A)) + ' W';
            document.getElementById('p20minValue').textContent = Math.round(ompd_power(1200, CP, W_prime, Pmax, A)) + ' W';
            document.getElementById('p30minValue').textContent = Math.round(ompd_power(1800, CP, W_prime, Pmax, A)) + ' W';

            // Show results section
            document.getElementById('resultsSection').style.display = 'block';

            // Create chart
            createChart(timeValues, powerValues, params);
            
            // Show selected points card if CSV data is available
            if (csvData) {
                populateSelectedPointsCard(timeValues, powerValues);
            } else {
                document.getElementById('selectedPointsCard').style.display = 'none';
            }
            
            quickCalculate();
        }

        // Create ECharts visualizations (3 charts)
        function createChart(timeValues, powerValues, params) {
            const [CP, W_prime, Pmax, A] = params;

            // Calcolo residui per il secondo grafico
            const predictions = timeValues.map(t => ompd_power(t, ...params));
            const residuals = powerValues.map((p, i) => p - predictions[i]);

            // Chart 1: Power-Duration Curve
            createPowerDurationChart(timeValues, powerValues, params, CP, W_prime, Pmax, A);
            
            // Chart 2: Residuals
            createResidualsChart(timeValues, residuals);
            
            // Chart 3: W'eff
            createWeffChart(W_prime, CP, Pmax);
        }

        function createPowerDurationChart(timeValues, powerValues, params, CP, W_prime, Pmax, A) {
            const chartDom = document.getElementById('chartContainer1');
            if (window.chart1) {
                window.chart1.dispose();
            }
            window.chart1 = echarts.init(chartDom, null, { height: 600 });

            // Generate fitted curve con punti logaritmicamente distribuiti
            const minTime = 1; // FISSO A 1 secondo
            const maxTime = 7200; // FISSO A 7200 secondi (2 ore) per mostrare il modello completo
            
            const numPoints = 300;
            const logMin = Math.log10(minTime);
            const logMax = Math.log10(maxTime);
            const fittedData = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const logT = logMin + (i / numPoints) * (logMax - logMin);
                const t = Math.pow(10, logT);
                fittedData.push([t, ompd_power(t, ...params)]);
            }

            const scatterData = timeValues.map((t, i) => [t, powerValues[i]]);

            const option = {
                title: {
                    text: 'OmPD Power-Duration Curve',
                    left: 'center',
                    textStyle: {
                        color: '#667eea',
                        fontSize: 20,
                        fontWeight: 'bold',
                        fontFamily: 'Crimson Pro'
                    }
                },
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: '#667eea',
                    borderWidth: 2,
                    textStyle: {
                        color: '#333',
                        fontFamily: 'Fira Code'
                    },
                    formatter: function(params) {
                        let result = `<strong>Time: ${formatTimeLabel(params[0].value[0])}</strong><br/>`;
                        params.forEach(param => {
                            result += `${param.marker} ${param.seriesName}: ${Math.round(param.value[1])} W<br/>`;
                        });
                        return result;
                    }
                },
                legend: {
                    show: false
                },
                grid: {
                    left: '10%',
                    right: '10%',
                    bottom: '15%',
                    top: '12%',
                    containLabel: true
                },
                xAxis: {
                    type: 'log',
                    name: 'Time',
                    nameLocation: 'middle',
                    nameGap: 40,
                    min: 1,
                    max: 7200,
                    nameTextStyle: {
                        color: '#667eea',
                        fontSize: 14,
                        fontWeight: 'bold',
                        fontFamily: 'Fira Code'
                    },
                    axisLine: {
                        lineStyle: {
                            color: '#667eea'
                        }
                    },
                    splitLine: {
                        lineStyle: {
                            color: 'rgba(102, 126, 234, 0.1)'
                        }
                    },
                    axisLabel: {
                        formatter: function(value) {
                            const logVal = Math.log10(value);
                            if (Math.abs(logVal - Math.round(logVal)) < 0.1) {
                                return formatTimeLabel(value);
                            }
                            return '';
                        },
                        color: '#666',
                        fontFamily: 'Fira Code'
                    }
                },
                yAxis: {
                    type: 'value',
                    name: 'Power (W)',
                    nameLocation: 'middle',
                    nameGap: 50,
                    nameTextStyle: {
                        color: '#667eea',
                        fontSize: 14,
                        fontWeight: 'bold',
                        fontFamily: 'Fira Code'
                    },
                    axisLine: {
                        lineStyle: {
                            color: '#667eea'
                        }
                    },
                    splitLine: {
                        lineStyle: {
                            color: 'rgba(102, 126, 234, 0.1)'
                        }
                    },
                    axisLabel: {
                        color: '#666',
                        fontFamily: 'Fira Code',
                        formatter: function(value) {
                            const maxValue = Math.max(...powerValues, Pmax) * 1.1;
                            // Nasconde il valore massimo (con tolleranza del 5%)
                            if (Math.abs(value - maxValue) / maxValue < 0.05) {
                                return '';
                            }
                            return Math.round(value);
                        }
                    },
                    min: 0,
                    max: Math.max(...powerValues, Pmax) * 1.1
                },
                series: [
                    {
                        name: 'Real Data',
                        type: 'scatter',
                        data: scatterData,
                        symbolSize: 12,
                        itemStyle: {
                            color: '#47c3f0',
                            borderColor: '#fff',
                            borderWidth: 2,
                            shadowBlur: 10,
                            shadowColor: 'rgba(71, 195, 240, 0.5)'
                        },
                        emphasis: {
                            scale: 1.5
                        },
                        z: 2
                    },
                    {
                        name: 'OmPD Model',
                        type: 'line',
                        data: fittedData,
                        smooth: false,
                        lineStyle: {
                            color: '#f06447',
                            width: 3,
                            shadowBlur: 10,
                            shadowColor: 'rgba(240, 100, 71, 0.5)'
                        },
                        itemStyle: {
                            color: '#f06447'
                        },
                        symbolSize: 0,
                        z: 1
                    },
                    {
                        name: 'CP Line',
                        type: 'line',
                        markLine: {
                            silent: true,
                            symbol: ['none', 'none'],
                            lineStyle: {
                                color: '#f06447',
                                type: 'dashed',
                                width: 2
                            },
                            label: {
                                formatter: 'CP',
                                position: 'end',
                                color: '#f06447',
                                fontFamily: 'Fira Code',
                                fontSize: 12,
                                fontWeight: 'bold'
                            },
                            data: [{yAxis: CP}]
                        }
                    }
                ],
                animationDuration: 1200,
                animationEasing: 'elasticOut'
            };

            window.chart1.setOption(option);
            window.addEventListener('resize', () => window.chart1.resize());
        }

        function createResidualsChart(timeValues, residuals) {
            const chartDom = document.getElementById('chartContainer2');
            if (window.chart2) {
                window.chart2.dispose();
            }
            window.chart2 = echarts.init(chartDom);

            const residualData = timeValues.map((t, i) => [t, residuals[i]]);
            const maxTime = Math.max(...timeValues);
            const xAxisMax = maxTime * 3; // Add 10% margin

            const option = {
                title: {
                    text: 'Model Residuals',
                    left: 'center',
                    textStyle: {
                        color: '#667eea',
                        fontSize: 20,
                        fontWeight: 'bold',
                        fontFamily: 'Crimson Pro'
                    }
                },
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: '#667eea',
                    borderWidth: 2,
                    textStyle: {
                        color: '#333',
                        fontFamily: 'Fira Code'
                    },
                    formatter: function(params) {
                        return `<strong>Time: ${formatTimeLabel(params[0].value[0])}</strong><br/>Residual: ${Math.round(params[0].value[1])} W`;
                    }
                },
                grid: {
                    left: '10%',
                    right: '10%',
                    bottom: '12%',
                    top: '12%',
                    containLabel: true
                },
                xAxis: {
                    type: 'log',
                    name: 'Time',
                    nameLocation: 'middle',
                    nameGap: 40,
                    min: 1,
                    max: xAxisMax,
                    nameTextStyle: {
                        color: '#667eea',
                        fontSize: 14,
                        fontWeight: 'bold',
                        fontFamily: 'Fira Code'
                    },
                    axisLine: {
                        show: false
                    },
                    axisTick: {
                        show: false
                    },
                    splitLine: {
                        show: false
                    },
                    axisLabel: {
                        formatter: function(value) {
                            const logVal = Math.log10(value);
                            if (Math.abs(logVal - Math.round(logVal)) < 0.1) {
                                return formatTimeLabel(value);
                            }
                            return '';
                        },
                        color: '#666',
                        fontFamily: 'Fira Code'
                    }
                },
                yAxis: {
                    type: 'value',
                    name: 'Residuals (W)',
                    nameLocation: 'middle',
                    nameGap: 50,
                    nameTextStyle: {
                        color: '#667eea',
                        fontSize: 14,
                        fontWeight: 'bold',
                        fontFamily: 'Fira Code'
                    },
                    axisLine: {
                        lineStyle: {
                            color: '#667eea'
                        }
                    },
                    splitLine: {
                        lineStyle: {
                            color: 'rgba(102, 126, 234, 0.1)'
                        }
                    },
                    axisLabel: {
                        color: '#666',
                        fontFamily: 'Fira Code'
                    },
                    min: -20,
                    max: 20
                },
                series: [
                    {
                        name: 'Residuals',
                        type: 'line',
                        data: residualData,
                        symbol: 'cross',
                        symbolSize: 10,
                        lineStyle: {
                            color: '#f06447',
                            width: 2
                        },
                        itemStyle: {
                            color: '#f06447',
                            borderWidth: 2
                        },
                        smooth: true
                    },
                    {
                        name: 'Zero Line',
                        type: 'line',
                        markLine: {
                            silent: true,
                            symbol: ['none', 'none'],
                            lineStyle: {
                                color: '#a8b2c0',
                                type: 'dashed',
                                width: 1
                            },
                            label: {
                                show: false
                            },
                            data: [{yAxis: 0}]
                        }
                    }
                ],
                animationDuration: 1200,
                animationEasing: 'elasticOut'
            };

            window.chart2.setOption(option);
            window.addEventListener('resize', () => window.chart2.resize());
        }

        function createWeffChart(W_prime, CP, Pmax) {
            const chartDom = document.getElementById('chartContainer3');
            if (window.chart3) {
                window.chart3.dispose();
            }
            window.chart3 = echarts.init(chartDom);

            // Calcolo W'eff
            const T_weff = Array.from({length: 500}, (_, i) => 1 + i * (300 - 1) / 499);
            const Weff_plot = T_weff.map(t => w_eff(t, W_prime, CP, Pmax));
            const W_99 = 0.99 * W_prime;
            const t_99_idx = Weff_plot.reduce((minIdx, val, idx, arr) => 
                Math.abs(val - W_99) < Math.abs(arr[minIdx] - W_99) ? idx : minIdx, 0);
            const t_99 = T_weff[t_99_idx];

            const weffData = T_weff.map((t, i) => [t, Weff_plot[i]]);

            const option = {
                title: {
                    text: 'Effective W\' Recovery',
                    left: 'center',
                    textStyle: {
                        color: '#667eea',
                        fontSize: 20,
                        fontWeight: 'bold',
                        fontFamily: 'Crimson Pro'
                    }
                },
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: '#667eea',
                    borderWidth: 2,
                    textStyle: {
                        color: '#333',
                        fontFamily: 'Fira Code'
                    },
                    formatter: function(params) {
                        return `<strong>Time: ${formatTimeLabel(params[0].value[0])}</strong><br/>W'eff: ${Math.round(params[0].value[1])} J`;
                    }
                },
                grid: {
                    left: '10%',
                    right: '10%',
                    bottom: '12%',
                    top: '12%',
                    containLabel: true
                },
                xAxis: {
                    type: 'log',
                    name: 'Time',
                    nameLocation: 'middle',
                    nameGap: 40,
                    min: 1,
                    max: 300,
                    nameTextStyle: {
                        color: '#667eea',
                        fontSize: 14,
                        fontWeight: 'bold',
                        fontFamily: 'Fira Code'
                    },
                    axisLine: {
                        lineStyle: {
                            color: '#667eea'
                        }
                    },
                    splitLine: {
                        lineStyle: {
                            color: 'rgba(102, 126, 234, 0.1)'
                        }
                    },
                    axisLabel: {
                        formatter: function(value) {
                            const logVal = Math.log10(value);
                            if (Math.abs(logVal - Math.round(logVal)) < 0.1) {
                                return formatTimeLabel(value);
                            }
                            return '';
                        },
                        color: '#666',
                        fontFamily: 'Fira Code'
                    }
                },
                yAxis: {
                    type: 'value',
                    name: 'W\'eff (J)',
                    nameLocation: 'middle',
                    nameGap: 50,
                    nameTextStyle: {
                        color: '#667eea',
                        fontSize: 14,
                        fontWeight: 'bold',
                        fontFamily: 'Fira Code'
                    },
                    axisLine: {
                        lineStyle: {
                            color: '#667eea'
                        }
                    },
                    splitLine: {
                        lineStyle: {
                            color: 'rgba(102, 126, 234, 0.1)'
                        }
                    },
                    axisLabel: {
                        formatter: function(value) {
                            return Math.round(value);
                        },
                        color: '#666',
                        fontFamily: 'Fira Code'
                    },
                    min: 0,
                    max: Math.max(...Weff_plot) * 1.1
                },
                series: [
                    {
                        name: 'W\'eff',
                        type: 'line',
                        data: weffData,
                        lineStyle: {
                            color: '#52c787',
                            width: 3,
                            shadowBlur: 10,
                            shadowColor: 'rgba(82, 199, 135, 0.5)'
                        },
                        itemStyle: {
                            color: '#52c787'
                        },
                        symbolSize: 0,
                        smooth: true
                    },
                    {
                        name: '99% W\'eff',
                        type: 'line',
                        markLine: {
                            silent: true,
                            symbol: ['none', 'none'],
                            lineStyle: {
                                color: '#47c3f0',
                                type: 'dashed',
                                width: 2
                            },
                            label: {
                                formatter: '99% W\'eff',
                                position: 'end',
                                color: '#47c3f0',
                                fontFamily: 'Fira Code',
                                fontSize: 12,
                                fontWeight: 'bold'
                            },
                            data: [{yAxis: W_99}]
                        },
                        markPoint: {
                            symbol: 'pin',
                            symbolSize: 60,
                            label: {
                                formatter: function() {
                                    return `${formatTimeLabel(t_99)}`;
                                },
                                color: '#fff',
                                fontFamily: 'Fira Code',
                                fontSize: 10,
                                fontWeight: 'bold'
                            },
                            itemStyle: {
                                color: '#47c3f0'
                            },
                            data: [{coord: [t_99, W_99]}]
                        }
                    }
                ],
                animationDuration: 1200,
                animationEasing: 'elasticOut'
            };

            window.chart3.setOption(option);
            window.addEventListener('resize', () => window.chart3.resize());
        }

        // Format time label
        function formatTimeLabel(seconds) {
            // Round to nearest integer to remove decimals
            seconds = Math.round(seconds);
            
            if (seconds < 60) return `${seconds}s`;
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            return `${h}h ${m}m`;
        }

        // Manual input functions
        let manualRowCount = 0;

        function createInputRows() {
            // Start with 4 rows
            for (let i = 0; i < 4; i++) {
                addInputRow();
            }
        }

        function addInputRow() {
            manualRowCount++;
            const container = document.getElementById('manualInputsContainer');
            const rowDiv = document.createElement('div');
            rowDiv.className = 'input-row-container';
            rowDiv.id = `row-${manualRowCount}`;
            
            rowDiv.innerHTML = `
                <div class="input-row">
                    <div class="input-field">
                        <label>Tempo (s)${manualRowCount === 1 ? ' (SPRINT 1-10s)' : ''}</label>
                        <input type="number" id="time-${manualRowCount}" placeholder="${manualRowCount === 1 ? 'es. 10' : 'es. 300'}" min="1">
                    </div>
                    <div class="input-field">
                        <label>Potenza (W)${manualRowCount === 1 ? ' (SPRINT 1-10s)' : ''}</label>
                        <input type="number" id="power-${manualRowCount}" placeholder="${manualRowCount === 1 ? 'es. 1000' : 'es. 250'}" min="1">
                    </div>
                    <button class="remove-btn" onclick="removeInputRow(${manualRowCount})">‚úï</button>
                </div>
            `;
            
            container.appendChild(rowDiv);
            
            // Add Enter key listener to trigger calculation
            const timeInput = document.getElementById(`time-${manualRowCount}`);
            const powerInput = document.getElementById(`power-${manualRowCount}`);
            
            timeInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    calculateFromManual();
                }
            });
            
            powerInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    calculateFromManual();
                }
            });
        }

        function removeInputRow(id) {
            const row = document.getElementById(`row-${id}`);
            if (row) {
                row.style.animation = 'fadeInUp 0.3s ease-out reverse';
                setTimeout(() => row.remove(), 300);
            }
        }

        function calculateFromManual() {
            const timeValues = [];
            const powerValues = [];

            for (let i = 1; i <= manualRowCount; i++) {
                const timeInput = document.getElementById(`time-${i}`);
                const powerInput = document.getElementById(`power-${i}`);
                
                if (timeInput && powerInput) {
                    const t = parseFloat(timeInput.value);
                    const p = parseFloat(powerInput.value);
                    
                    if (!isNaN(t) && !isNaN(p) && t > 0 && p > 0) {
                        timeValues.push(t);
                        powerValues.push(p);
                    }
                }
            }

            if (timeValues.length < 4) {
                showCustomAlert('Inserisci almeno 4 coppie valide di tempo-potenza!');
                return;
            }

            performCalculation(timeValues, powerValues);
            
            // Scroll to results
            setTimeout(() => {
                document.getElementById('resultsSection').scrollIntoView({behavior: 'smooth', block: 'start'});
            }, 200);
        }

        // CSV handling (MANTIENE LA LOGICA ORIGINALE)
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                parseCSV(text);
            };
            reader.readAsText(file);
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            
            const colTimeSelect = document.getElementById('colTime');
            const colPowerSelect = document.getElementById('colPower');
            
            colTimeSelect.innerHTML = '';
            colPowerSelect.innerHTML = '';
            
            headers.forEach(header => {
                const option1 = document.createElement('option');
                option1.value = header;
                option1.textContent = header;
                colTimeSelect.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = header;
                option2.textContent = header;
                colPowerSelect.appendChild(option2);
            });

            // Auto-select "This season" as power column if present
            const thisSeasonIndex = headers.findIndex(h => 
                h.toLowerCase().trim() === 'this season' || 
                h.toLowerCase().trim() === '"this season"'
            );
            if (thisSeasonIndex !== -1) {
                colPowerSelect.selectedIndex = thisSeasonIndex;
            }

            // Store parsed data
            window.csvRawData = {headers, lines: lines.slice(1)};
            
            document.getElementById('csvControls').style.display = 'block';
            
            // Auto-scroll to CSV controls
            setTimeout(() => {
                document.getElementById('csvControls').scrollIntoView({behavior: 'smooth', block: 'center'});
            }, 100);
        }

        function importCSVData() {
            if (!window.csvRawData) return;

            const colTime = document.getElementById('colTime').value;
            const colPower = document.getElementById('colPower').value;

            if (colTime === colPower) {
                showCustomAlert('Impossibile selezionare la stessa colonna per tempo e potenza!');
                return;
            }

            const timeIdx = window.csvRawData.headers.indexOf(colTime);
            const powerIdx = window.csvRawData.headers.indexOf(colPower);

            // Leggo tutti i punti numerici validi (t>0, p>0)
            const allTimes = [];
            const allPowers = [];
            window.csvRawData.lines.forEach(line => {
                const values = line.split(',');
                const t = parseFloat(values[timeIdx]);
                const p = parseFloat(values[powerIdx]);
                if (!isNaN(t) && !isNaN(p) && t > 0 && p > 0) {
                    allTimes.push(t);
                    allPowers.push(p);
                }
            });

            if (allTimes.length < 4) {
                showCustomAlert('Non ci sono abbastanza dati validi nel CSV!');
                return;
            }

            // Provo a fitare l'intera curva per calcolare i residuals
            try {
                const sprintSeconds = Math.max(1, parseFloat(document.getElementById('sprintSeconds').value) || 10);
                const minPct = Math.max(0, Math.min(100, parseFloat(document.getElementById('minPercentile').value) || 70));
                const valuesPerWindow = Math.max(1, parseInt(document.getElementById('valuesPerWindow').value) || 1);

                let selectedTimes = [];
                let selectedPowers = [];
                let selectedMask = new Array(allTimes.length).fill(false);

                if (allTimes.length >= 4) {
                    const params = curveFit(allTimes, allPowers);
                    const predictions = allTimes.map((t) => ompd_power(t, ...params));
                    const residuals = allPowers.map((p, i) => p - predictions[i]);
                    
                    // Salva i residui globalmente per ricalcoli futuri
                    allResiduals = residuals;

                    // Calculate percentile threshold on ALL residuals
                    const residualsClean = residuals.filter(r => !isNaN(r));
                    let percentileThreshold = -Infinity;
                    if (residualsClean.length > 0) {
                        residualsClean.sort((a, b) => a - b);
                        const rank = Math.ceil((minPct / 100) * residualsClean.length) - 1;
                        const idx = Math.max(0, Math.min(residualsClean.length - 1, rank));
                        percentileThreshold = residualsClean[idx];
                        if (isNaN(percentileThreshold)) {
                            percentileThreshold = Math.min(...residualsClean);
                        }
                    }

                    // Define time windows: default Python windows
                    const timeWindows = [
                        [120, 240],
                        [240, 480],
                        [480, 900],
                        [900, 1800],
                        [1800, 2700]
                    ];

                    // For each window, select points
                    for (const [tmin, tmax] of timeWindows) {
                        const windowIndices = [];
                        for (let i = 0; i < allTimes.length; i++) {
                            if (allTimes[i] >= tmin && allTimes[i] <= tmax) {
                                windowIndices.push(i);
                            }
                        }
                        if (windowIndices.length === 0) continue;

                        // Sort window indices by residual descending (highest first)
                        const sortedIndices = windowIndices.sort((a, b) => residuals[b] - residuals[a]);

                        // Take up to valuesPerWindow where residual >= threshold
                        let count = 0;
                        for (const i of sortedIndices) {
                            if (!isNaN(residuals[i]) && residuals[i] >= percentileThreshold && !selectedMask[i]) {
                                selectedTimes.push(allTimes[i]);
                                selectedPowers.push(allPowers[i]);
                                selectedMask[i] = true;
                                count++;
                                if (count >= valuesPerWindow) break;
                            }
                        }
                    }

                    // Sprint selection: add the closest sprint point if not already selected
                    if (sprintSeconds > 0) {
                        let minDist = Infinity;
                        let sprintIdx = -1;
                        for (let i = 0; i < allTimes.length; i++) {
                            const dist = Math.abs(allTimes[i] - sprintSeconds);
                            if (dist < minDist) {
                                minDist = dist;
                                sprintIdx = i;
                            }
                        }
                        if (sprintIdx >= 0 && !selectedMask[sprintIdx] && !isNaN(allTimes[sprintIdx]) && !isNaN(allPowers[sprintIdx])) {
                            selectedTimes.push(allTimes[sprintIdx]);
                            selectedPowers.push(allPowers[sprintIdx]);
                            selectedMask[sprintIdx] = true;
                        }
                    }
                }

                // Check if any data selected
                if (selectedTimes.length === 0) {
                    throw new Error("POCHI DATI! Diminuisci il filtro percentile");
                }

                // Sort selected data by time for proper plotting
                const sortedIndices = selectedTimes.map((_, i) => i).sort((a, b) => selectedTimes[a] - selectedTimes[b]);
                selectedTimes = sortedIndices.map(i => selectedTimes[i]);
                selectedPowers = sortedIndices.map(i => selectedPowers[i]);

                csvData = { timeValues: selectedTimes, powerValues: selectedPowers };

                // Remove previous alert messages only
                const csvControls = document.getElementById('csvControls');
                const alerts = csvControls.querySelectorAll('.alert');
                alerts.forEach(alert => alert.remove());

                const alertDiv = document.createElement('div');
                alertDiv.className = 'alert alert-success';
                alertDiv.textContent = `‚úÖ Dati importati: ${allTimes.length} punti totali, selezionati ${selectedTimes.length} punti`;
                csvControls.appendChild(alertDiv);

                performCalculation(selectedTimes, selectedPowers);
                
                // Scroll automatico alla tabella dei risultati
                setTimeout(function() {
                    document.getElementById('resultsSection').scrollIntoView({behavior: 'smooth', block: 'start'});
                }, 200);
            } catch (e) {
                console.error('Errore importCSVData:', e);
                showCustomAlert('Errore durante il processamento del CSV. Controlla il formato e riprova.');
            }
        }

        // Apply percentile filter when value changes
        function applyPercentileFilter() {
            // Se non c'√® dati caricati, esci
            if (allTimes.length < 4 || allResiduals.length === 0) {
                return;
            }

            const sprintSeconds = Math.max(1, parseFloat(document.getElementById('sprintSeconds').value) || 10);
            const minPct = Math.max(0, Math.min(100, parseFloat(document.getElementById('minPercentile').value) || 70));
            const valuesPerWindow = Math.max(1, parseInt(document.getElementById('valuesPerWindow').value) || 1);

            let selectedTimes = [];
            let selectedPowers = [];
            let selectedMask = new Array(allTimes.length).fill(false);

            // Calculate percentile threshold on residuals (same as omniselector)
            const residualsClean = allResiduals.filter(r => !isNaN(r));
            let percentileThreshold = 0;
            if (residualsClean.length > 0) {
                residualsClean.sort((a, b) => a - b);
                // Calcola il percentile usando la formula di numpy (linear interpolation)
                const h = (residualsClean.length - 1) * (minPct / 100);
                const floor_idx = Math.floor(h);
                const ceil_idx = Math.ceil(h);
                const frac = h - floor_idx;
                
                if (floor_idx === ceil_idx) {
                    percentileThreshold = residualsClean[floor_idx];
                } else {
                    percentileThreshold = residualsClean[floor_idx] * (1 - frac) + residualsClean[ceil_idx] * frac;
                }
                if (isNaN(percentileThreshold)) {
                    percentileThreshold = Math.min(...residualsClean);
                }
            }

            // Define time windows: default Python windows
            const timeWindows = [
                [120, 240],
                [240, 480],
                [480, 900],
                [900, 1800],
                [1800, 2700]
            ];

            // For each window, select points
            for (const [tmin, tmax] of timeWindows) {
                const windowIndices = [];
                for (let i = 0; i < allTimes.length; i++) {
                    if (allTimes[i] >= tmin && allTimes[i] <= tmax) {
                        windowIndices.push(i);
                    }
                }
                if (windowIndices.length === 0) continue;

                // Sort window indices by residual descending (highest first)
                const sortedIndices = windowIndices.sort((a, b) => allResiduals[b] - allResiduals[a]);

                // Take up to valuesPerWindow where residual >= threshold
                let count = 0;
                for (const i of sortedIndices) {
                    if (!isNaN(allResiduals[i]) && allResiduals[i] >= percentileThreshold && !selectedMask[i]) {
                        selectedTimes.push(allTimes[i]);
                        selectedPowers.push(allPowers[i]);
                        selectedMask[i] = true;
                        count++;
                        if (count >= valuesPerWindow) break;
                    }
                }
            }

            // Sprint selection: add the closest sprint point if not already selected
            if (sprintSeconds > 0) {
                let minDist = Infinity;
                let sprintIdx = -1;
                for (let i = 0; i < allTimes.length; i++) {
                    const dist = Math.abs(allTimes[i] - sprintSeconds);
                    if (dist < minDist) {
                        minDist = dist;
                        sprintIdx = i;
                    }
                }
                if (sprintIdx >= 0 && !selectedMask[sprintIdx] && !isNaN(allTimes[sprintIdx]) && !isNaN(allPowers[sprintIdx])) {
                    selectedTimes.push(allTimes[sprintIdx]);
                    selectedPowers.push(allPowers[sprintIdx]);
                    selectedMask[sprintIdx] = true;
                }
            }

            // Check if any data selected
            if (selectedTimes.length === 0) {
                throw new Error("Nessun dato selezionato dalle finestre temporali con questo percentile");
            }

            console.log(`Percentile ${minPct}: ${selectedTimes.length} punti selezionati (soglia: ${percentileThreshold.toFixed(2)})`);

            // Sort selected data by time for proper plotting
            const sortedIndices = selectedTimes.map((_, i) => i).sort((a, b) => selectedTimes[a] - selectedTimes[b]);
            selectedTimes = sortedIndices.map(i => selectedTimes[i]);
            selectedPowers = sortedIndices.map(i => selectedPowers[i]);

            // Update csvData and recalculate
            csvData = { timeValues: selectedTimes, powerValues: selectedPowers };
            performCalculation(selectedTimes, selectedPowers);

            // Scroll to results
            setTimeout(function() {
                document.getElementById('resultsSection').scrollIntoView({behavior: 'smooth', block: 'start'});
            }, 200);
        }

        // Quick calculator
        function quickCalculate() {
            if (!calculatedParams) {
                document.getElementById('quickResult').innerHTML = 
                    '<div class="alert alert-warning">‚ö†Ô∏è Per calcolare √® necessario importare CSV O calcolare con i valori manuali</div>';
                return;
            }

            const t = parseFloat(document.getElementById('tCalc').value) || 1200;
            const {CP, W_prime, Pmax, A} = calculatedParams;
            const P_calc = ompd_power(t, CP, W_prime, Pmax, A);
            
            let html = `<div class="quick-calc-result">${formatTimeLabel(t)} ‚Üí ${Math.round(P_calc)} W</div>`;
            html += '<p style="font-size: 0.875rem; color: #666; margin-top: 10px; text-align: center;">(per aggiornare premere "Enter" dopo aver cambiato t)</p>';

            document.getElementById('quickResult').innerHTML = html;
        }

        // Modal functions
        function showCustomAlert(message, title = 'Attenzione', icon = '‚ö†Ô∏è') {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            document.querySelector('.modal-icon').textContent = icon;
            document.getElementById('customModal').classList.add('show');
            
            document.addEventListener('keydown', handleEscape);
            document.getElementById('customModal').addEventListener('click', handleOutsideClick);
        }

        function closeModal() {
            document.getElementById('customModal').classList.remove('show');
            document.removeEventListener('keydown', handleEscape);
            document.getElementById('customModal').removeEventListener('click', handleOutsideClick);
        }

        function handleEscape(event) {
            if (event.key === 'Escape') {
                closeModal();
            }
        }

        function handleOutsideClick(event) {
            if (event.target.id === 'customModal') {
                closeModal();
            }
        }

        // Initialize
        createInputRows();

        // Add event listeners for percentile filter recalculation
        document.getElementById('minPercentile').addEventListener('change', applyPercentileFilter);
        document.getElementById('valuesPerWindow').addEventListener('change', applyPercentileFilter);
        document.getElementById('sprintSeconds').addEventListener('change', applyPercentileFilter);
    </script>
</body>
</html>
